from pymodbus.client.sync import ModbusTcpClient
from pymodbus.transaction import ModbusRtuFramer as ModbusFramer
from pymodbus.exceptions import ModbusIOException
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime
import time
import json
import socket
import requests
import json
import pymysql
# 전역 변수 셋팅
####################################################전체 전역 변수 셋팅(ip,port,address,get_count)##################################
# URL = 'http://15.15.15.162:8000/api/'      # 그랜드 썬 내부 IP
URL = 'http://127.0.0.1:8000/api/'      # 내 PC 내부 IP

HEADERS = {'Content-Type': 'application/json', 'charset': 'UTF-8', 'Accept': '*/*'}
#IP 셋팅
RICE_PADDY_SERVER_IP = '223.171.136.17' #논
FIELD_SERVER_IP = '223.171.136.18'      # 밭
ORCHARD_SERVER_IP = '223.171.136.19'    #과수원
GEOCHANG_SERVER_IP = '223.171.136.36'   #거창
SALTERN_SERVER_IP = '223.171.136.86'    #염전
ALL_SERVER_IP = [SALTERN_SERVER_IP,RICE_PADDY_SERVER_IP,FIELD_SERVER_IP,ORCHARD_SERVER_IP,GEOCHANG_SERVER_IP]
#SLAVE ID 셋팅
SLAVE_ID_1_6 = [1,2,3,4,5,6]   #기상센서 (1~4) 수평 (5) 풍속 (6)    #100kW인버터 (1)
SLAVE_ID_RICE_PADDY = [21,20,19]    #인버터 논 4002         # 25kW  채널 1,2,3
SLAVE_ID_GEOCHANG = [0x63, 0x5C, 0x1C, 0x60]   #인버터 거창 4002       # 3.5kW 채널 1,2,3,4
SLAVE_ID_SALTERN_25kW = [61,55]     # 포트상으로는 [4003, 4004] 25kw    채널 1,2
SLAVE_ID_SALTERN_3kW = [0x18,0x49,0x61,0x1D,0x20,0x25] # 포트상으로는 4005  3kw 채널 3~8
# 채널 번호 셋팅
GEOCHANG3K_CH = [1,2,3,4]
SALTERN25K_CH = [3,4,5,6,7,8]
#PORT 셋팅
SERVER_PORT_4001 = 4001 #기상센서 포트
SERVER_PORT_4002 = 4002 # 논,밭,과수원, 거창 인버터 포트
SERVER_PORT_4003_4004 = [4003,4004]     # slave_id = [61,55]
SERVER_PORT_4005 = 4005 # 염전 3.5KW 6대
#100kW 인버터 셋팅
SETTING_100kW = {'start_address':[22,33282,1006],'get_count': [48,60,6]}
# Env 셋팅
SETTING_ENV = {'start_address':[5,22],'get_count': [10,46]}

# 풍향 text 셋팅
directions = ["북", "북동", "동", "남동", "남", "남서", "서", "북서","북"]
start_angles = [0, 21, 71, 111, 161, 201, 251, 291, 341]
end_angles = [20, 70, 110, 160, 200, 250, 290, 340, 360]
# 3.5kW 인버터 시리얼키 셋팅
first = 0x0A
second =0x96
four =0x54
five = 0x18
six = 0x05
#db 셋팅
db_ip = '1.223.240.125'   #그랜드썬 외부 IP
# db_ip = '15.15.15.161'      #그랜드썬 내부 IP
db_port = 3306
db_user = 'grandsun'
db_password = 'grandsun!@'
db_db = 'new_rnd'
# 재요청 횟수
MAX_RETRIES = 5
# Scheduler 셋팅
Service_Cron = '12,24,36,48'
DB_Cron = '0'
###############################################################################################################################
class MyApp(QWidget):

    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle('My First Application') #창의 제목
        self.move(300, 300)                         #위젯을 스크린의 x,y 위치로 이동
        self.resize(400, 200)                       #위젯의 크기를 너비,높이로 조절
        self.show()                                 #위젯을 스크린에 보여줌
class Modbus():
    def read_holding_registers_modbus(client,address,num,slave_id):
        retries = 0
        # while retries < MAX_RETRIES:
        while True:
            try:
                # 값 받아오는 부분
                response = client.read_holding_registers(address, num, unit=slave_id)
                # 못받았을때 예외 처리 None으로 값을 넘김
                if response.isError():
                    retries += 1
                    print(f"retrie {retries}COUNT Modbus Error for Register {address}: {response}")
                    # return None
                else:
                    data = response.registers
                    return data
            except ModbusIOException as e:
                retries += 1
                print(f"retrie {retries}COUNT Modbus Communication Error for Register {address}: {e}")
                # return None
    def read_input_registers_modbus(client,address,num,slave_id):
        retries = 0
        # while retries < MAX_RETRIES:
        while True:
            try:
                # 값 받아오는 부분
                response = client.read_input_registers(address, num, unit=slave_id)
                if response.isError():
                    retries += 1
                    # print(f"retrie {retries}COUNT Modbus Error for Register {address}: {response}")
                    # # return None
                else:
                    data = response.registers
                    return data
            except ModbusIOException as e:
                retries += 1
                print(f"retrie {retries}COUNT Modbus Communication Error for Register {address}: {e}")
                # return None
class DB():
    def selectQuery(query, distinct=None):
        connection = pymysql.connect(
            host = db_ip,
            port = db_port,
            db = 'new_rnd',
            user = 'grandsun',
            password = 'grandsun!@',
            charset = 'utf8'
        )
        with connection.cursor() as cursor:
            cursor.execute(query)
            columns = [column[0] for column in cursor.description]

            queryset = []
            temp = None
            for row in cursor.fetchall():
                if distinct != None:    #중복제거
                    if temp != row[distinct]:
                        queryset.append(dict(zip(columns, row)))
                        temp = row[distinct]
                else:
                    queryset.append(dict(zip(columns, row)))
            return queryset
    def updateQuery(query):
        conn = pymysql.connect (host=db_ip,port=db_port,user=db_user,password=db_password,db=db_db,charset='utf8')    #DB 접속
        cursor = conn.cursor()
        cursor.execute(query)
        conn.commit()   #db저장
    def time_3min_check():
            demon_area_query = 'SELECT id FROM tb_demonstration_area'
            demon_area_query_set = DB.selectQuery(demon_area_query)
            now_time = datetime.now()
            for demon_area in demon_area_query_set:
                demon_area_id = demon_area['id']
                table_name_query = f'SELECT table_name FROM tb_inv_check WHERE demon_area_id_id = {demon_area_id}'
                table_name_query_set = DB.selectQuery(table_name_query)
                table_name = table_name_query_set[0]['table_name']
                device_id_query = f'SELECT id FROM tb_info_inv_setting WHERE demon_area_id_id = {demon_area_id}'
                device_id_query_set = DB.selectQuery(device_id_query)
                for device in device_id_query_set:
                    device_id = device['id']
                    # total 들어왔는지 여부로 판단할거
                    data_info_id_id = 18
                    info_id_query = f'SELECT id FROM tb_info_data_composition WHERE device_id_id = {device_id} AND data_info_id_id = {data_info_id_id}'
                    info_id_query_set = DB.selectQuery(info_id_query)
                    time_check_query = f'SELECT create_datetime FROM {table_name} WHERE data_id_id = {info_id_query_set[0]["id"]} ORDER BY id DESC LIMIT 1'
                    time_check_query_set = DB.selectQuery(time_check_query)
                    time_check = time_check_query_set[0]['create_datetime']
                    time_difference = now_time - time_check 
                    days_difference = time_difference.days
                    seconds_difference = time_difference.seconds
                    minutes_difference = seconds_difference // 60
                        
                    if days_difference >= 0 and minutes_difference > 3:
                        status_code = 0 # modbus 상태 불량
                        time_check = time_check.strftime('%Y-%m-%d %H:%M:%S')
                        update_query = f'UPDATE tb_inv_modbus_conn SET status_code ={status_code}, end_datetime = "{time_check}" WHERE device_id_id={device_id}'
                    else:
                        status_code = 1 # modbus 상태 정상
                        update_query = f'UPDATE tb_inv_modbus_conn SET status_code ={status_code} WHERE device_id_id={device_id}'
                    DB.updateQuery(update_query)
    def key_setting(data_set):
        demon_area_id_id = data_set['demon_area_id_id']
        device_id = data_set['device_id']
        table_name = DB.Demonstration_Area_table_Check(demon_area_id_id)
        # 인버터에 센싱할 데이터가 아닌 대상들 딕셔너리에서 제외
        delete_keys = ['demon_area_id_id','device_id','sensing_type','error','state']   
        for delete_key in delete_keys:
            if delete_key in data_set:
                del data_set[delete_key]
        result = []
        for key, value in data_set.items():
            parts = key.rsplit('_', 1)
            if len(parts) == 2 and parts[1].isdigit():
                name = parts[0]
                label = int(parts[1])
                result.append({"name": name, "label": label, "value": value})
        query = 'SELECT id, name FROM tb_info_inv_data'
        query_set = DB.selectQuery(query)   # id, 이름
        data_id_ids_to_save = []
        values_to_save = []
    
        for data in result:
            for info in query_set:
                if data['name'] == info['name']:
                    data_info_id_id = info['id']
                    composition_query = f'SELECT id FROM tb_info_data_composition WHERE data_label = {data["label"]} AND data_info_id_id = {data_info_id_id} AND demon_area_id_id = {demon_area_id_id} AND device_id_id = {device_id}'
                    composition_query_set = DB.selectQuery(composition_query)
                    data_id_ids_to_save.append(composition_query_set[0]['id'])
                    values_to_save.append(data['value'])
                    break
        DB.Inv_data_db_save(table_name,values_to_save,data_id_ids_to_save)
           
    def Inv_data_db_save(table_name, values, data_id_ids):
        create_datetime = datetime.today()
        date_id = int(create_datetime.strftime("%Y%m%d"))

        with pymysql.connect(host=db_ip, port=db_port, user=db_user, password=db_password, db=db_db, charset='utf8') as conn:
            with conn.cursor() as cursor:
                # 여러 행의 값을 한 번에 삽입하기 위해 VALUES 다음에 여러 행을 쉼표로 구분하여 추가
                values_str = ', '.join([f"({value}, {date_id}, NOW(), {data_id_id})" for value, data_id_id in zip(values, data_id_ids)])

                query = f"INSERT INTO {table_name} (value, date_id, create_datetime, data_id_id) VALUES {values_str}"
                
                
                try:
                    cursor.execute(query)
                    conn.commit()  # Ensure to commit changes
                except Exception as e:
                    print("Error:", e)
                    print("Query execution failed.")
    def Demonstration_Area_table_Check(demon_area_id_id):
        query = f'SELECT table_name FROM tb_inv_check WHERE demon_area_id_id = {demon_area_id_id}'
        query_set = DB.selectQuery(query)
        table_name = query_set[0]['table_name']
        return table_name
    def Error_log_inserte_query(device_id_id,error_code,error_log):
        conn = pymysql.connect (host=db_ip,port=db_port,user=db_user,password=db_password,db=db_db,charset='utf8')    #DB 접속
        cursor = conn.cursor()
        query = (
                "INSERT INTO tb_error_log_device "
                "(error_value, create_datetime, devcie_id_id, error_code) "
                "VALUES "
                "(%s, NOW(), %s, %s)"
                )
        values = (error_log,device_id_id,error_code)
        try:
            cursor.execute(query, values)
            conn.commit()
        except Exception as e:
            print(f"Error: {e}")
        finally:
            cursor.close()
            conn.close()
    def Error_log_save(device_id,error_code,fault_100):
        query = f'SELECT protocol_power FROM tb_info_inv_type WHERE id =(SELECT inv_type_id_id FROM tb_info_inv_setting WHERE id = {device_id})'
        query_set = DB.selectQuery(query)
        protocol_power =query_set[0]['protocol_power']
        if protocol_power == 3.5:
            if error_code is not None:
                if error_code == 1:
                    error_log = '태양 전지 과 전류'
                elif error_code == 2:
                    error_log ='태양 전지 과 전압'
                elif error_code == 3:
                    error_log ='태양 전지 저 전압'
                elif error_code == 4:
                    error_log ='DCLink 과 전압'
                elif error_code == 5:
                    error_log ='DCLink 저 전압'
                elif error_code == 6:
                    error_log ='인버터 과 전류'
                elif error_code == 7:
                    error_log ='계통 과 전압'
                elif error_code == 8:
                    error_log ='계통 저 전압'
                elif error_code == 9:
                    error_log ='내부 온도 초과'
                elif error_code == 10:
                    error_log ='계통 과 주파수'
                elif error_code == 11:
                    error_log ='계통 저 주파수'
                elif error_code == 12:
                    error_log ='태양 전지 과 전력'
                elif error_code == 13:
                    error_log ='DC 성분 규정치 초과'
                elif error_code == 14:
                    error_log ='DC 배선 누전'
                elif error_code == 15:
                    error_log ='+절연 저항'
                elif error_code == 16:
                    error_log ='Reserved'
                elif error_code == 17:
                    error_log ='단독 운전'
                elif error_code == 18:
                    error_log ='인버터 과 전류 HW'
                elif error_code == 19:
                    error_log ='-절연 저항'
                elif error_code == 20:
                    error_log ='내부 절연 저항'
                elif error_code == 21:
                    error_log ='누설 전류 자가 진단'
                if error_code != 0:
                    DB.Error_log_inserte_query(device_id,error_code,error_log)
        elif protocol_power == 25:
            if error_code is not None:
                if error_code == 1:
                    error_log ='태양 과 전류'
                elif error_code == 2:
                    error_log ='태양 과 전압'
                elif error_code == 3:
                    error_log ='태양 저 전압'
                elif error_code == 4:
                    error_log ='DCLink 과 전압'
                elif error_code == 5:
                    error_log ='DCLink 저 전압'
                elif error_code == 6:
                    error_log ='인버터 과 전류'
                elif error_code == 7:
                    error_log ='계통 과 전압'
                elif error_code == 8:
                    error_log ='계통 저 전압'
                elif error_code == 9:
                    error_log ='내부 온도 초과'
                elif error_code == 10:
                    error_log ='계통 과 주파수'
                elif error_code == 11:
                    error_log ='계통 저 주파수'
                elif error_code == 12:
                    error_log ='계통 과 전력'
                elif error_code == 13:
                    error_log ='AC 전류 DC 성분'
                elif error_code == 14:
                    error_log ='DC 배선 누전'
                elif error_code == 15:
                    error_log ='절연 저항 NG'
                elif error_code == 16:
                    error_log ='AC 위상 연결 NG'
                elif error_code == 17:
                    error_log ='인버터 HW 전류'
                elif error_code == 18:
                    error_log ='단독 운전 방지'
                elif error_code == 19:
                    error_log ='릴레이 융착'
                elif error_code == 20:
                    error_log ='릴레이 전압 NG'
                elif error_code == 21:
                    error_log ='DCLink OV HW'
                if error_code != 0:
                    DB.Error_log_inserte_query(device_id,error_code,error_log)
        elif protocol_power == 100:
            if fault_100['fault0'] is not None:
                if fault_100['fault0'] != 0:
                    error_log = f'fault0에러 ErrorCode={fault_100["fault0"]}'
                    DB.Error_log_inserte_query(device_id,fault_100["fault0"],error_log)
                if fault_100['fault1'] != 0:
                    error_log = f'fault1에러 ErrorCode={fault_100["fault1"]}'
                    DB.Error_log_inserte_query(device_id,fault_100["fault1"],error_log)
                if fault_100['fault2'] != 0:
                    error_log = f'fault2에러 ErrorCode={fault_100["fault2"]}'
                    DB.Error_log_inserte_query(device_id,fault_100["fault2"],error_log)
                if fault_100['fault3'] != 0:
                    error_log = f'fault3에러 ErrorCode={fault_100["fault3"]}'
                    DB.Error_log_inserte_query(device_id,fault_100["fault3"],error_log)
                if fault_100['fault4'] != 0:
                    error_log = f'fault4에러 ErrorCode={fault_100["fault4"]}'
                    DB.Error_log_inserte_query(device_id,fault_100["fault4"],error_log)
        
    def Env_data_db_save(data_dic,db_dic):
        conn = pymysql.connect (host=db_ip,port=db_port,user=db_user,password=db_password,db=db_db,charset='utf8')    #DB 접속
        cursor = conn.cursor()
        create_datetime = datetime.today()
        date_id = int(create_datetime.strftime("%Y%m%d"))
        query = (
                "INSERT INTO tb_env_data "
                "(sun_1, sun_2, sun_3, sun_4, sun_5, module_temp_1, module_temp_3, soil_temp_2, "
                "soil_temp_4, soil_temp_5, wd_n, wd_t, ws, ws_1minute_max, date_id, create_datetime, demon_area_id_id) "
                "VALUES "
                "(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), %s)"
            )
        values = (
                    data_dic["sun_1"], data_dic["sun_2"], data_dic["sun_3"],
                    data_dic["sun_4"], data_dic["sun_5"], data_dic["module_temp_1"],
                    data_dic["module_temp_3"], data_dic["soil_temp_2"], data_dic["soil_temp_4"],
                    data_dic["soil_temp_5"], data_dic["wd_n"], db_dic["wd_t"],
                    data_dic["ws"], db_dic["ws_1minute_max"], date_id, data_dic["demon_area_id_id"]
                )
        try:
            cursor.execute(query, values)
            conn.commit()
        except Exception as e:
            print(f"Error: {e}")
        finally:
            cursor.close()
            conn.close()
    def Env_Modbus(ip,port,reg_settings,slave_id_list):
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            address_setting = reg_settings['start_address']
            get_count_setting = reg_settings['get_count']
            data_dic = {'sun_1': None,
                        'sun_2': None,
                        'sun_3': None,
                        'sun_4': None,
                        'sun_5': None,
                        'module_temp_1': None,
                        'module_temp_3':None,
                        'soil_temp_2' : None,
                        'soil_temp_4' : None,
                        'soil_temp_5' : None,
                        'wd_n' : None,
                        'ws' : None,
                        }
            db_dic = {'wd_t' : None,
                      'ws_1minute_max': None,
                      }
            for slave_id in slave_id_list:
                if slave_id != 6:
                    address = address_setting[0]
                    get_count = get_count_setting[0]
                else:
                    address = address_setting[1]
                    get_count = get_count_setting[1]
                data_set = Modbus.read_input_registers_modbus(client, address, get_count,slave_id)
                if data_set is not None:
                    if slave_id != 6:
                        data_dic[f'sun_{slave_id}'] = data_set[0]
                        if ip[-2:] == '86': #염전 
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 5:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                        elif ip[-2:] == '36':   #거창
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 4:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                        else:   #논 밭 과수원
                            if slave_id == 1:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 2:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                    elif slave_id == 6:
                        ws = round(data_set[-1] * 0.1,1)
                        wd_n = round(data_set[0] * 0.1 ,1)
                        data_dic['wd_n'] = wd_n
                        data_dic['ws'] = ws
                        wd_t =Service.calculate_8_wind_direction(wd_n)
                        db_dic['wd_t'] = wd_t
            json_key_name = 'WS_SAVE_'
            ip_save = ip[-2:]   # json파일에서 ws 저장 하는 용도로 쓸것
            json_name = json_key_name + str(ip_save)
            with open('grandsun_ws_save.json') as f:
                json_data = json.load(f)
            if data_dic['ws'] is not None:
                if data_dic['ws'] > json_data[json_name]:
                    db_dic['ws_1minute_max'] = data_dic['ws']
                else:
                    db_dic['ws_1minute_max'] = json_data[json_name]
            else:
                db_dic['ws_1minute_max'] = json_data[json_name]
                
            json_data[json_name] = 0
            with open('grandsun_ws_save.json','w',encoding='utf-8') as save_file:
                json.dump(json_data,save_file,indent='\t')
            if ip[-2:] == '86':
                demon_area_id_id = 1
            elif ip[-2:] == '17':
                demon_area_id_id = 2
            elif ip[-2:] == '18':
                demon_area_id_id = 3
            elif ip[-2:] == '19':
                demon_area_id_id = 4
            elif ip[-2:] == '36':
                demon_area_id_id = 5
            else:
                demon_area_id_id = None
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['sensing_type'] = 2
            DB.Env_data_db_save(data_dic,db_dic)
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')      
            Service.send_api_to_flatform(data_dic) 
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()
    def Inv_Modbus_3kW_SALTERN():
        for index in range(1,7):
            while True:
                # 소켓 생성
                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                try:
                    # 서버에 연결
                    client_socket.connect((SALTERN_SERVER_IP, SERVER_PORT_4005))

                    # 요청 바이트 배열 생성
                    request_bytes = bytearray([first, second, SLAVE_ID_SALTERN_3kW[index - 1], four, five, six, (four + five + SLAVE_ID_SALTERN_3kW[index - 1])])

                    # 요청 데이터를 서버로 전송하고 응답을 받음
                    response_bytes = Service.send_receive_data(client_socket, request_bytes)
                    
                    data_dict = {
                        'pv_volt_1': None,
                        'pv_current_1': None,
                        'pv_power_1' : None,
                        'volt_1': None,
                        'current_1': None,
                        'output_power_1' : None,
                        'temp_1': None,
                        'today_power_1': None,
                        'total_1': None,
                        'error': None,
                        'state': None,
                        'frequency_1': None,
                        'demon_area_id_id' : None,
                        'device_id' : None,
                        'sensing_type' : None,
                    }
                    pv_volt_1 =    int(response_bytes.hex()[8:10] + response_bytes.hex()[6:8], 16) / 10
                    pv_current_1 = int(response_bytes.hex()[12:14] + response_bytes.hex()[10:12], 16) / 10
                    volt_1 = int(response_bytes.hex()[20:22] + response_bytes.hex()[18:20], 16) / 10
                    current_1 = int(response_bytes.hex()[24:26] + response_bytes.hex()[22:24], 16) / 10
                    data_dict['pv_volt_1'] =    round(pv_volt_1,2)
                    data_dict['pv_current_1'] = round(pv_current_1,2)
                    data_dict['pv_power_1'] = round(pv_volt_1 * pv_current_1/1000,6)
                    data_dict['volt_1'] =    round(volt_1,2)
                    data_dict['current_1'] = round(current_1,2)
                    data_dict['output_power_1'] = round(volt_1 * current_1/1000,6)
                    data_dict['temp_1'] = round(int(response_bytes.hex()[28:30] + response_bytes.hex()[26:28], 16) / 10, 2)
                    data_dict['today_power_1'] = round(int(response_bytes.hex()[32:34] + response_bytes.hex()[30:32], 16) / 100, 2)
                    data_dict['total_1'] = int(response_bytes.hex()[38:40] + response_bytes.hex()[36:38] + response_bytes.hex()[34:36], 16)
                    data_dict['error'] = int(response_bytes.hex()[48:46] + response_bytes.hex()[44:46] + response_bytes.hex()[42:44] + response_bytes.hex()[40:42], 16)
                    data_dict['state'] = int(response_bytes.hex()[48:50], 16)
                    data_dict['frequency_1'] = round(int(response_bytes.hex()[52:54] + response_bytes.hex()[50:52], 16) / 10, 2)
                    data_dict['demon_area_id_id'] = 1
                    data_dict['device_id'] = index + 2
                    data_dict['sensing_type'] = 1
                    if data_dict['error'] < 100:    #100보다 크면 값 잘못읽어온걸로 취급
                        break
                    
                except Exception as e:
                    print(f"Error for index {index}: {e}")
                finally:
                    DB.Error_log_save(data_dict['device_id'],data_dict['error'],None)
                    Service.send_api_to_flatform(data_dict) 
                    DB.key_setting(data_dict)
                    client_socket.close()
                # 소켓 닫기
    def Inv_Modbus_3kW_GEOCHANG():
        for index in range(1,5):
            while True:
            #소켓 생성
                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                try:
                # 서버에 연결
                    client_socket.connect((GEOCHANG_SERVER_IP, SERVER_PORT_4002))
                    # 요청 바이트 배열 생성
                    request_bytes = bytearray([first, second, SLAVE_ID_GEOCHANG[index - 1], four, five, six, (four + five + SLAVE_ID_GEOCHANG[index - 1])])
                    # 요청 데이터를 서버로 전송하고 응답을 받음
                    response_bytes = Service.send_receive_data(client_socket, request_bytes)
                    
                    data_dict = {
                        'pv_volt_1': None,
                        'pv_current_1': None,
                        'pv_power_1' : None,
                        'volt_1': None,
                        'current_1': None,
                        'output_power_1' : None,
                        'temp_1': None,
                        'today_power_1': None,
                        'total_1': None,
                        'error': None,
                        'state': None,
                        'frequency_1': None,
                        'demon_area_id_id' : None,
                        'device_id' : None,
                        'sensing_type' : None,
                    }
                    pv_volt_1 =    int(response_bytes.hex()[8:10] + response_bytes.hex()[6:8], 16) / 10
                    pv_current_1 = int(response_bytes.hex()[12:14] + response_bytes.hex()[10:12], 16) / 10
                    volt_1 =     int(response_bytes.hex()[20:22] + response_bytes.hex()[18:20], 16) / 10
                    current_1 = int(response_bytes.hex()[24:26] + response_bytes.hex()[22:24], 16) / 10
                    data_dict['pv_volt_1'] =    round(pv_volt_1,2)
                    data_dict['pv_current_1'] = round(pv_current_1,2)
                    data_dict['pv_power_1'] = round(pv_volt_1 * pv_current_1/1000,6)
                    data_dict['volt_1'] =    round(volt_1,2)
                    data_dict['current_1'] = round(current_1,2)
                    data_dict['output_power_1'] = round(volt_1 * current_1/1000,6)
                    data_dict['temp_1'] = round(int(response_bytes.hex()[28:30] + response_bytes.hex()[26:28], 16) / 10, 2)
                    data_dict['today_power_1'] = round(int(response_bytes.hex()[32:34] + response_bytes.hex()[30:32], 16) / 100, 2)
                    data_dict['total_1'] = int(response_bytes.hex()[38:40] + response_bytes.hex()[36:38] + response_bytes.hex()[34:36], 16)
                    data_dict['error'] = int(response_bytes.hex()[48:46] + response_bytes.hex()[44:46] + response_bytes.hex()[42:44] + response_bytes.hex()[40:42], 16)
                    data_dict['state'] = int(response_bytes.hex()[48:50], 16)
                    data_dict['frequency_1'] = round(int(response_bytes.hex()[52:54] + response_bytes.hex()[50:52], 16) / 10, 2)
                    data_dict['demon_area_id_id'] = 5
                    data_dict['device_id'] = index + 13
                    data_dict['sensing_type'] = 1
                    if data_dict['error'] < 100:    #100보다 크면 값 잘못읽어온걸로 취급
                        break
                    
                except Exception as e:
                    print(f"Error for index {index}: {e}")
                finally:
                    DB.Error_log_save(data_dict['device_id'],data_dict['error'],None)
                    Service.send_api_to_flatform(data_dict) 
                    DB.key_setting(data_dict)
                    client_socket.close()
    
    def Inv_Modbus_25kW(ip,port,slave_id,demon_area_id_id,device_id):
        # 클라이언트 연결
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            address_25 = 30049
            get_count_25 = 27
            data_set = Modbus.read_input_registers_modbus(client, address_25, get_count_25,slave_id)
            data_dic = {}
            if data_set is not None:
                r_current_1 = data_set[0] / 10
                data_dic['r_current_1'] = round(r_current_1,2)
                data_dic['s_current_1'] = round(data_set[1] / 10, 2)
                data_dic['t_current_1'] = round(data_set[2] / 10, 2)
                rs_volt_1 = data_set[3]
                data_dic['rs_volt_1'] = rs_volt_1
                data_dic['output_power_1'] = round(r_current_1 * rs_volt_1/1000,6)
                data_dic['st_volt_1'] = data_set[4]
                data_dic['tr_volt_1'] = data_set[5]
                data_dic['today_power_1'] = round((data_set[6] << 16 | data_set[7]) / 100, 2)
                data_dic['state'] = data_set[8]
                data_dic['error'] = data_set[9]
                data_dic['total_1'] = data_set[11] << 16 | data_set[12]
                for i in range(13, 25, 2):
                    pv_current = data_set[i] / 10
                    pv_volt = data_set[i + 1]
                    data_dic[f'pv_current_{(i - 11) // 2}'] = round(pv_current,2)
                    data_dic[f'pv_volt_{(i - 11) // 2}'] = pv_volt
                    data_dic[f'pv_power_{(i - 11) // 2}'] = round(pv_current * pv_volt/1000,6)
                data_dic['temp_1'] = round(data_set[25] / 10, 2)
                data_dic['frequency_1'] = round(data_set[26] / 10 ,2)
            else:
                data_dic['r_current_1'] = None
                data_dic['s_current_1'] = None
                data_dic['t_current_1'] = None
                data_dic['rs_volt_1'] = None
                data_dic['st_volt_1'] = None
                data_dic['tr_volt_1'] = None
                data_dic['today_power_1'] = None
                data_dic['state'] = None
                data_dic['error'] = None
                data_dic['total_1'] = None
                data_dic['output_power_1'] = None
                for i in range(13, 25, 2):
                    data_dic[f'pv_current_{(i - 11) // 2}'] = None
                    data_dic[f'pv_volt_{(i - 11) // 2}'] = None
                    data_dic[f'pv_power_{(i - 11) // 2}'] = None
                data_dic['temp_1'] = None
                data_dic['frequency_1'] = None
                print("Failed to receive data.")
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['device_id'] = device_id
            data_dic['sensing_type'] = 1
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')
            DB.Error_log_save(data_dic['device_id'],data_dic['error'],None)
            Service.send_api_to_flatform(data_dic)
            DB.key_setting(data_dic)
             
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()   
    def Inv_Modbus_100kW(ip,port,reg_settings,slave_id,demon_area_id_id,device_id):
        # 클라이언트 연결
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            # 주소값
            address_setting = reg_settings['start_address']
            # 가져올 갯수
            get_count_setting = reg_settings['get_count']
            # 만약 주소가 한개라 해도 반복문은 이상없음 현재까지는 
            # 주소 인덱스랑 가져올 갯수 인덱스가 같아서 이렇게 처리함 다를 경우 조건 추가 할 예정
            data_dic = {}
            error_dic = {}
            for index in range(len(address_setting)):
                address = address_setting[index]
                get_count = get_count_setting[index]
                if index == 0 or index == 1:
                    data_set = Modbus.read_input_registers_modbus(client, address, get_count,slave_id)
                else:
                    data_set = Modbus.read_holding_registers_modbus(client, address, get_count,slave_id)
                if data_set is not None:
                    if index == 0:
                        data = [value - (1 << 16) if value & (1 << 15) else value for value in data_set]
                        data_dic['total_1'] = (data[0] << 16) | data[1]
                        data_dic['today_power_1'] = round(0.1 * data[2], 2)
                        data_dic['power_factor_1'] = 0.1 * data[4]
                        data_dic['pac_today_max_1'] = round(0.1 * data[5],2)
                        data_dic['output_power_1'] = round(0.1 * data[7], 2)#29
                        data_dic['rs_volt_1'] = round(0.1 * data[9], 2)#31
                        data_dic['st_volt_1'] = round(0.1 * data[10], 2)#32
                        data_dic['tr_volt_1'] = round(0.1 * data[11], 2)#33
                        data_dic['r_current_1'] = round(0.1 * data[12], 2)#34
                        data_dic['s_current_1'] = round(0.1 * data[13], 2)#35
                        data_dic['t_current_1'] = round(0.1 * data[14], 2)#36
                        data_dic['frequency_1'] = data[21]#43
                        data_dic['temp_1'] = round(0.1 * data[23], 2)#45
                        data_dic['state'] = data[25]    #47
                        data_dic['pdc_1'] = round(0.1 * data[-1], 2)
                        error_dic['fault0'] = data[32]   #54 #0이 defalt 값인거 같음
                        error_dic['fault1'] = data[33]
                        error_dic['fault2'] = data[34]
                        error_dic['fault3'] = data[35]
                        error_dic['fault4'] = data[36]
                    elif index == 1:    #pv_volt,pv_current값들
                        result = data_set[:6] + data_set[48:]
                        for i in range(1, int(len(result) / 2) + 1):
                            pv_volt = result[((i-1) * 2)] * 0.1
                            pv_current = result[((i-1) * 2) + 1] * 0.1
                            pv_power = pv_volt * pv_current
                            data_dic[f'pv_volt_{i}'] = round(pv_volt, 3)
                            data_dic[f'pv_current_{i}'] = round(pv_current, 3)
                            data_dic[f'pv_power_{i}'] = round(pv_power/1000,6)
                    elif index == 2:
                        data = data_set
                        data_dic['r_volt_1'] = round(0.1 * data[1], 2)
                        data_dic['s_volt_1'] = round(0.1 * data[3], 2)
                        data_dic['t_volt_1'] = round(0.1 * data[5], 2)
                else:
                    if index == 0:
                        data_dic['total_1'] = None
                        data_dic['today_power_1'] = None
                        data_dic['power_factor_1'] = None
                        data_dic['pac_today_max_1'] =None
                        data_dic['output_power_1'] = None
                        data_dic['rs_volt_1'] = None
                        data_dic['st_volt_1'] = None
                        data_dic['tr_volt_1'] = None
                        data_dic['r_current_1'] = None
                        data_dic['s_current_1'] = None
                        data_dic['t_current_1'] = None
                        data_dic['frequency_1'] = None
                        data_dic['temp_1'] = None
                        data_dic['state'] = None
                        error_dic['fault0'] = None
                        error_dic['fault1'] = None
                        error_dic['fault2'] = None
                        error_dic['fault3'] = None
                        error_dic['fault4'] = None
                        data_dic['pdc_1'] = None
                    elif index == 1:    #pv_volt,pv_current값들
                        for i in range(1, 9):
                            data_dic[f'pv_volt_{i}'] = None
                            data_dic[f'pv_current_{i}'] = None
                            data_dic[f'pv_power_{i}'] = None
                    elif index == 2:
                        data_dic['r_volt_1'] = None
                        data_dic['s_volt_1'] = None
                        data_dic['t_volt_1'] = None
                    # 에러가 발생한 경우 또는 데이터를 읽어오지 못한 경우 어떻게 처리 해야할지 결정해야 할듯 함
                    # 에러로그 저장할 쿼리 진행 예정
                    print("Failed to receive data.")
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['device_id'] = device_id
            data_dic['sensing_type'] = 1
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')
            DB.Error_log_save(data_dic['device_id'],None,error_dic)
            Service.send_api_to_flatform(data_dic) 
            DB.key_setting(data_dic)
            
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()
    
class Service():
    def send_api_to_flatform(post_data):
        try:
            response = requests.post(URL, headers=HEADERS, data=json.dumps(post_data, ensure_ascii=False, indent="\t"))
            print("post success: ", datetime.now())
        except Exception as ex:
            print(ex)     
    def calculate_8_wind_direction(wind_direction): # 8방위 기준으로 계산
        # 주어진 풍향값이 어느 범위에 속하는지 확인
        for i in range(len(directions)):
            if start_angles[i] <= wind_direction < end_angles[i]:
                return directions[i]
    def Env_Modbus(ip,port,reg_settings,slave_id_list):
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            address_setting = reg_settings['start_address']
            get_count_setting = reg_settings['get_count']
            data_dic = {}
            for slave_id in slave_id_list:
                if slave_id != 6:
                    address = address_setting[0]
                    get_count = get_count_setting[0]
                else:
                    address = address_setting[1]
                    get_count = get_count_setting[1]
                data_set = Modbus.read_input_registers_modbus(client, address, get_count,slave_id)
                if data_set is not None:
                    if slave_id != 6:
                        data_dic[f'sun_{slave_id}'] = data_set[0]
                        if ip[-2:] == '86': #염전 
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 5:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                        elif ip[-2:] == '36':   #거창
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 4:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                        else:   #논 밭 과수원
                            if slave_id == 1:
                                data_dic[f'module_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                            elif slave_id == 2:
                                data_dic[f'soil_temp_{slave_id}'] = round((data_set[-1] - 27315) / 100, 2)
                    elif slave_id == 6:
                        ws = round(data_set[-1] * 0.1,1)
                        wd_n = round(data_set[0] * 0.1 ,1)
                        data_dic['wd_n'] = wd_n
                        data_dic['ws'] = ws
                        # wd_t =Service.calculate_8_wind_direction(wd_n)
                        # wd_t = wd_t.encode('utf-8')
                        # data_dic['wd_t'] = wd_t
                        json_key_name = 'WS_SAVE_'
                        ip_save = ip[-2:]   # json파일에서 ws 저장 하는 용도로 쓸것
                        json_name = json_key_name + str(ip_save)
                        with open('grandsun_ws_save.json') as f:
                            json_data = json.load(f)
                        if json_data[json_name] < ws:
                            json_data[json_name] = ws
                            # data_dic['ws_1minute_max'] = ws
                            with open('grandsun_ws_save.json','w',encoding='utf-8') as save_file:
                                json.dump(json_data,save_file,indent='\t')
                        # else:
                            # data_dic['ws_1minute_max'] = json_data[json_name]
                else:
                    if slave_id != 6:
                        data_dic[f'sun_{slave_id}'] = None
                        if ip[-2:] == '86': #염전 
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = None
                            elif slave_id == 5:
                                data_dic[f'soil_temp_{slave_id}'] = None
                        elif ip[-2:] == '36':   #거창
                            if slave_id == 3:
                                data_dic[f'module_temp_{slave_id}'] = None
                            elif slave_id == 4:
                                data_dic[f'soil_temp_{slave_id}'] = None
                        else:   #논 밭 과수원
                            if slave_id == 1:
                                data_dic[f'module_temp_{slave_id}'] = None
                            elif slave_id == 2:
                                data_dic[f'soil_temp_{slave_id}'] = None
                    elif slave_id == 6:
                        data_dic['wd_n'] = None
                        data_dic['ws'] = None
                        # data_dic['wd_t'] = None
                    # 에러가 발생한 경우 또는 데이터를 읽어오지 못한 경우 어떻게 처리 해야할지 결정해야 할듯 함
                    # 에러로그 저장할 쿼리 진행 예정
                    print("Failed to receive data.")
            if ip[-2:] == '86':
                demon_area_id_id = 1
            elif ip[-2:] == '17':
                demon_area_id_id = 2
            elif ip[-2:] == '18':
                demon_area_id_id = 3
            elif ip[-2:] == '19':
                demon_area_id_id = 4
            elif ip[-2:] == '36':
                demon_area_id_id = 5
            else:
                demon_area_id_id = None
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['sensing_type'] = 2
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')      
            Service.send_api_to_flatform(data_dic) 
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()
    
    def send_receive_data(socket, request_bytes):
        try:
            # 데이터를 서버에 보내기
            socket.send(request_bytes)
            # 서버로부터 응답 데이터 수신
            response_bytes = bytearray()  # 데이터를 저장할 버퍼 생성
            while len(response_bytes) < 31:  # 원하는 바이트 수만큼 수신할 때까지 반복
                received_data = socket.recv(31 - len(response_bytes))  # 남은 바이트 수만큼 읽어옴
                if not received_data:
                    # 만약 데이터를 더 이상 수신하지 못하면 루프 종료
                    break
                response_bytes.extend(received_data)  # 수신한 데이터를 버퍼에 추가
            # 수신된 응답 데이터 출력
            print("Received Response:", response_bytes.hex())
            
            return response_bytes
        except Exception as e:
            print("Error:", e)
            return None
    def Inv_Modbus_3kW_SALTERN():
        for index in range(1,7):
            while True:
                # 소켓 생성
                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                try:
                    # 서버에 연결
                    client_socket.connect((SALTERN_SERVER_IP, SERVER_PORT_4005))

                    # 요청 바이트 배열 생성
                    request_bytes = bytearray([first, second, SLAVE_ID_SALTERN_3kW[index - 1], four, five, six, (four + five + SLAVE_ID_SALTERN_3kW[index - 1])])

                    # 요청 데이터를 서버로 전송하고 응답을 받음
                    response_bytes = Service.send_receive_data(client_socket, request_bytes)
                    
                    data_dict = {
                        'pv_volt_1': None,
                        'pv_current_1': None,
                        'pv_power_1' : None,
                        'volt_1': None,
                        'current_1': None,
                        'output_power_1' : None,
                        'temp_1': None,
                        'today_power_1': None,
                        'total_1': None,
                        'error': None,
                        'state': None,
                        'frequency_1': None,
                        'demon_area_id_id' : None,
                        'device_id' : None,
                        'sensing_type' : None,
                    }
                    pv_volt_1 =    int(response_bytes.hex()[8:10] + response_bytes.hex()[6:8], 16) / 10
                    pv_current_1 = int(response_bytes.hex()[12:14] + response_bytes.hex()[10:12], 16) / 10
                    volt_1 = int(response_bytes.hex()[20:22] + response_bytes.hex()[18:20], 16) / 10
                    current_1 = int(response_bytes.hex()[24:26] + response_bytes.hex()[22:24], 16) / 10
                    data_dict['pv_volt_1'] =    round(pv_volt_1,2)
                    data_dict['pv_current_1'] = round(pv_current_1,2)
                    data_dict['pv_power_1'] = round(pv_volt_1 * pv_current_1/1000,6)
                    data_dict['volt_1'] =    round(volt_1,2)
                    data_dict['current_1'] = round(current_1,2)
                    data_dict['output_power_1'] = round(volt_1 * current_1/1000,6)
                    data_dict['temp_1'] = round(int(response_bytes.hex()[28:30] + response_bytes.hex()[26:28], 16) / 10, 2)
                    data_dict['today_power_1'] = round(int(response_bytes.hex()[32:34] + response_bytes.hex()[30:32], 16) / 100, 2)
                    data_dict['total_1'] = int(response_bytes.hex()[38:40] + response_bytes.hex()[36:38] + response_bytes.hex()[34:36], 16)
                    data_dict['error'] = int(response_bytes.hex()[48:46] + response_bytes.hex()[44:46] + response_bytes.hex()[42:44] + response_bytes.hex()[40:42], 16)
                    data_dict['state'] = int(response_bytes.hex()[48:50], 16)
                    data_dict['frequency_1'] = round(int(response_bytes.hex()[52:54] + response_bytes.hex()[50:52], 16) / 10, 2)
                    data_dict['demon_area_id_id'] = 1
                    data_dict['device_id'] = index + 2
                    data_dict['sensing_type'] = 1
                    if data_dict['error'] < 100:    #100보다 크면 값 잘못읽어온걸로 취급
                        break
                    
                except Exception as e:
                    print(f"Error for index {index}: {e}")
                finally:
                    Service.send_api_to_flatform(data_dict) 
                    client_socket.close()
                # 소켓 닫기
    def Inv_Modbus_3kW_GEOCHANG():
        for index in range(1,5):
            while True:
            #소켓 생성
                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                try:
                # 서버에 연결
                    client_socket.connect((GEOCHANG_SERVER_IP, SERVER_PORT_4002))
                    # 요청 바이트 배열 생성
                    request_bytes = bytearray([first, second, SLAVE_ID_GEOCHANG[index - 1], four, five, six, (four + five + SLAVE_ID_GEOCHANG[index - 1])])
                    # 요청 데이터를 서버로 전송하고 응답을 받음
                    response_bytes = Service.send_receive_data(client_socket, request_bytes)
                    
                    data_dict = {
                        'pv_volt_1': None,
                        'pv_current_1': None,
                        'pv_power_1' : None,
                        'volt_1': None,
                        'current_1': None,
                        'output_power_1' : None,
                        'temp_1': None,
                        'today_power_1': None,
                        'total_1': None,
                        'error': None,
                        'state': None,
                        'frequency_1': None,
                        'demon_area_id_id' : None,
                        'device_id' : None,
                        'sensing_type' : None,
                    }
                    pv_volt_1 =    int(response_bytes.hex()[8:10] + response_bytes.hex()[6:8], 16) / 10
                    pv_current_1 = int(response_bytes.hex()[12:14] + response_bytes.hex()[10:12], 16) / 10
                    volt_1 =     int(response_bytes.hex()[20:22] + response_bytes.hex()[18:20], 16) / 10
                    current_1 = int(response_bytes.hex()[24:26] + response_bytes.hex()[22:24], 16) / 10
                    data_dict['pv_volt_1'] =    round(pv_volt_1,2)
                    data_dict['pv_current_1'] = round(pv_current_1,2)
                    data_dict['pv_power_1'] = round(pv_volt_1 * pv_current_1/1000,6)
                    data_dict['volt_1'] =    round(volt_1,2)
                    data_dict['current_1'] = round(current_1,2)
                    data_dict['output_power_1'] = round(volt_1 * current_1/1000,6)
                    data_dict['temp_1'] = round(int(response_bytes.hex()[28:30] + response_bytes.hex()[26:28], 16) / 10, 2)
                    data_dict['today_power_1'] = round(int(response_bytes.hex()[32:34] + response_bytes.hex()[30:32], 16) / 100, 2)
                    data_dict['total_1'] = int(response_bytes.hex()[38:40] + response_bytes.hex()[36:38] + response_bytes.hex()[34:36], 16)
                    data_dict['error'] = int(response_bytes.hex()[48:46] + response_bytes.hex()[44:46] + response_bytes.hex()[42:44] + response_bytes.hex()[40:42], 16)
                    data_dict['state'] = int(response_bytes.hex()[48:50], 16)
                    data_dict['frequency_1'] = round(int(response_bytes.hex()[52:54] + response_bytes.hex()[50:52], 16) / 10, 2)
                    data_dict['demon_area_id_id'] = 5
                    data_dict['device_id'] = index + 13
                    data_dict['sensing_type'] = 1
                    if data_dict['error'] < 100:    #100보다 크면 값 잘못읽어온걸로 취급
                        break
                    
                except Exception as e:
                    print(f"Error for index {index}: {e}")
                finally:
                    Service.send_api_to_flatform(data_dict) 
                    client_socket.close()
    
    def Inv_Modbus_25kW(ip,port,slave_id,demon_area_id_id,device_id):
        # 클라이언트 연결
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            address_25 = 30049
            get_count_25 = 27
            data_set = Modbus.read_input_registers_modbus(client, address_25, get_count_25,slave_id)
            data_dic = {}
            if data_set is not None:
                r_current_1 = data_set[0] / 10
                data_dic['r_current_1'] = round(r_current_1,2)
                data_dic['s_current_1'] = round(data_set[1] / 10, 2)
                data_dic['t_current_1'] = round(data_set[2] / 10, 2)
                rs_volt_1 = data_set[3]
                data_dic['rs_volt_1'] = rs_volt_1
                data_dic['output_power_1'] = round(r_current_1 * rs_volt_1/1000,6)
                data_dic['st_volt_1'] = data_set[4]
                data_dic['tr_volt_1'] = data_set[5]
                data_dic['today_power_1'] = round((data_set[6] << 16 | data_set[7]) / 100, 2)
                data_dic['state'] = data_set[8]
                data_dic['error'] = data_set[9]
                data_dic['total_1'] = data_set[11] << 16 | data_set[12]
                for i in range(13, 25, 2):
                    pv_current = data_set[i] / 10
                    pv_volt = data_set[i + 1]
                    data_dic[f'pv_current_{(i - 11) // 2}'] = round(pv_current,2)
                    data_dic[f'pv_volt_{(i - 11) // 2}'] = pv_volt
                    data_dic[f'pv_power_{(i - 11) // 2}'] = round(pv_current * pv_volt/1000,6)
                data_dic['temp_1'] = round(data_set[25] / 10, 2)
                data_dic['frequency_1'] = round(data_set[26] / 10 ,2)
            else:
                data_dic['r_current_1'] = None
                data_dic['s_current_1'] = None
                data_dic['t_current_1'] = None
                data_dic['rs_volt_1'] = None
                data_dic['st_volt_1'] = None
                data_dic['tr_volt_1'] = None
                data_dic['today_power_1'] = None
                data_dic['state'] = None
                data_dic['error'] = None
                data_dic['total_1'] = None
                data_dic['output_power_1'] = None
                for i in range(13, 25, 2):
                    data_dic[f'pv_current_{(i - 11) // 2}'] = None
                    data_dic[f'pv_volt_{(i - 11) // 2}'] = None
                    data_dic[f'pv_power_{(i - 11) // 2}'] = None
                data_dic['temp_1'] = None
                data_dic['frequency_1'] = None
                print("Failed to receive data.")
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['device_id'] = device_id
            data_dic['sensing_type'] = 1
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')
            Service.send_api_to_flatform(data_dic) 
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()   
    
    def Inv_Modbus_100kW(ip,port,reg_settings,slave_id,demon_area_id_id,device_id):
        # 클라이언트 연결
        client = ModbusTcpClient(ip, port=port, framer=ModbusFramer)
        try:
            client.connect()
            # 주소값
            address_setting = reg_settings['start_address']
            # 가져올 갯수
            get_count_setting = reg_settings['get_count']
            # 만약 주소가 한개라 해도 반복문은 이상없음 현재까지는 
            # 주소 인덱스랑 가져올 갯수 인덱스가 같아서 이렇게 처리함 다를 경우 조건 추가 할 예정
            data_dic = {}
            error_dic = {}
            for index in range(len(address_setting)):
                address = address_setting[index]
                get_count = get_count_setting[index]
                if index == 0 or index == 1:
                    data_set = Modbus.read_input_registers_modbus(client, address, get_count,slave_id)
                else:
                    data_set = Modbus.read_holding_registers_modbus(client, address, get_count,slave_id)
                if data_set is not None:
                    if index == 0:
                        data = [value - (1 << 16) if value & (1 << 15) else value for value in data_set]
                        data_dic['total_1'] = (data[0] << 16) | data[1]
                        data_dic['today_power_1'] = round(0.1 * data[2], 2)
                        data_dic['power_factor_1'] = 0.1 * data[4]
                        data_dic['pac_today_max_1'] = round(0.1 * data[5],2)
                        data_dic['output_power_1'] = round(0.1 * data[7], 2)#29
                        data_dic['rs_volt_1'] = round(0.1 * data[9], 2)#31
                        data_dic['st_volt_1'] = round(0.1 * data[10], 2)#32
                        data_dic['tr_volt_1'] = round(0.1 * data[11], 2)#33
                        data_dic['r_current_1'] = round(0.1 * data[12], 2)#34
                        data_dic['s_current_1'] = round(0.1 * data[13], 2)#35
                        data_dic['t_current_1'] = round(0.1 * data[14], 2)#36
                        data_dic['frequency_1'] = data[21]#43
                        data_dic['temp_1'] = round(0.1 * data[23], 2)#45
                        data_dic['state'] = data[25]    #47
                        error_dic['fault0'] = data[32]   #54 #0이 defalt 값인거 같음
                        error_dic['fault1'] = data[33]
                        error_dic['fault2'] = data[34]
                        error_dic['fault3'] = data[35]
                        error_dic['fault4'] = data[36]
                        data_dic['pdc_1'] = round(0.1 * data[-1], 2)
                    elif index == 1:    #pv_volt,pv_current값들
                        result = data_set[:6] + data_set[48:]
                        for i in range(1, int(len(result) / 2) + 1):
                            pv_volt = result[((i-1) * 2)] * 0.1
                            pv_current = result[((i-1) * 2) + 1] * 0.1
                            pv_power = pv_volt * pv_current
                            data_dic[f'pv_volt_{i}'] = round(pv_volt, 3)
                            data_dic[f'pv_current_{i}'] = round(pv_current, 3)
                            data_dic[f'pv_power_{i}'] = round(pv_power/1000,6)
                    elif index == 2:
                        data = data_set
                        data_dic['r_volt_1'] = round(0.1 * data[1], 2)
                        data_dic['s_volt_1'] = round(0.1 * data[3], 2)
                        data_dic['t_volt_1'] = round(0.1 * data[5], 2)
                else:
                    if index == 0:
                        data_dic['total_1'] = None
                        data_dic['today_power_1'] = None
                        data_dic['power_factor_1'] = None
                        data_dic['pac_today_max_1'] =None
                        data_dic['output_power_1'] = None
                        data_dic['rs_volt_1'] = None
                        data_dic['st_volt_1'] = None
                        data_dic['tr_volt_1'] = None
                        data_dic['r_current_1'] = None
                        data_dic['s_current_1'] = None
                        data_dic['t_current_1'] = None
                        data_dic['frequency_1'] = None
                        data_dic['temp_1'] = None
                        data_dic['state'] = None
                        error_dic['fault0'] = None
                        error_dic['fault1'] = None
                        error_dic['fault2'] = None
                        error_dic['fault3'] = None
                        error_dic['fault4'] = None
                        data_dic['pdc_1'] = None
                    elif index == 1:    #pv_volt,pv_current값들
                        for i in range(1, 9):
                            data_dic[f'pv_volt_{i}'] = None
                            data_dic[f'pv_current_{i}'] = None
                            data_dic[f'pv_power_{i}'] = None
                    elif index == 2:
                        data_dic['r_volt_1'] = None
                        data_dic['s_volt_1'] = None
                        data_dic['t_volt_1'] = None
                    # 에러가 발생한 경우 또는 데이터를 읽어오지 못한 경우 어떻게 처리 해야할지 결정해야 할듯 함
                    # 에러로그 저장할 쿼리 진행 예정
                    print("Failed to receive data.")
            data_dic['demon_area_id_id'] = demon_area_id_id
            data_dic['device_id'] = device_id
            data_dic['sensing_type'] = 1
            print('#################################################################################')
            print(f"{ip}({port}) 모든 데이터 : {data_dic}")
            print('#################################################################################')
            Service.send_api_to_flatform(data_dic) 
            # 이제 모든 키값들을 tb_data_info 의 이름들과 매칭시켜 db에 데이터 저장할 예정
        except Exception as e:
            # 에러로그 저장할 쿼리 진행 예정
            print(f"Service Error: {e}")
        finally:
            # 클라이언트를 닫음
            client.close()

    
class Schedulerer:
    def backgroundScheduler():
        sched = BackgroundScheduler()
        sched.start()
        # #환경 데이터 스케줄러
        
        sched.add_job(DB.time_3min_check, 'cron', minute= '*/3') 
        
        for server_ip in ALL_SERVER_IP:     
            sched.add_job(Service.Env_Modbus, 'cron', second= Service_Cron,misfire_grace_time = 5,args=(server_ip,SERVER_PORT_4001,SETTING_ENV,SLAVE_ID_1_6)) 
            sched.add_job(DB.Env_Modbus, 'cron', second= DB_Cron,misfire_grace_time = 5,args=(server_ip,SERVER_PORT_4001,SETTING_ENV,SLAVE_ID_1_6))     
        # 3KW 염전
        sched.add_job(Service.Inv_Modbus_3kW_SALTERN, 'cron', second= Service_Cron,misfire_grace_time = 5)
        sched.add_job(DB.Inv_Modbus_3kW_SALTERN, 'cron', second= DB_Cron ,misfire_grace_time = 5)
        # 3KW 거창
        sched.add_job(Service.Inv_Modbus_3kW_GEOCHANG, 'cron', second= Service_Cron,misfire_grace_time = 5)
        sched.add_job(DB.Inv_Modbus_3kW_GEOCHANG, 'cron', second= DB_Cron,misfire_grace_time = 5)
        
        #25kw 논 25k_1,25k_2,25k_3
        for slave_id,device_id in zip(SLAVE_ID_RICE_PADDY,[9,10,11]): 
            sched.add_job(Service.Inv_Modbus_25kW, 'cron', second= Service_Cron,misfire_grace_time = 5,args=(RICE_PADDY_SERVER_IP,SERVER_PORT_4002,slave_id,2,device_id))
            sched.add_job(DB.Inv_Modbus_25kW, 'cron', second= DB_Cron,misfire_grace_time = 5,args=(RICE_PADDY_SERVER_IP,SERVER_PORT_4002,slave_id,2,device_id))
            
        # # 25kw 염전 25k_1, 25k_2
        for sever_port, slave_id,device_id in zip(SERVER_PORT_4003_4004,SLAVE_ID_SALTERN_25kW,[1,2]):
            sched.add_job(Service.Inv_Modbus_25kW, 'cron', second= Service_Cron,misfire_grace_time = 5,args=(SALTERN_SERVER_IP,sever_port,slave_id,1,device_id))
            sched.add_job(DB.Inv_Modbus_25kW, 'cron', second= DB_Cron,misfire_grace_time = 5,args=(SALTERN_SERVER_IP,sever_port,slave_id,1,device_id))
            
        # #100kW 인버터 스케줄러
        # #과수원
        sched.add_job(Service.Inv_Modbus_100kW, 'cron', second= Service_Cron,misfire_grace_time = 5,args=(ORCHARD_SERVER_IP,SERVER_PORT_4002,SETTING_100kW,SLAVE_ID_1_6[0],4,13))     
        sched.add_job(DB.Inv_Modbus_100kW, 'cron', second= DB_Cron,misfire_grace_time = 5,args=(ORCHARD_SERVER_IP,SERVER_PORT_4002,SETTING_100kW,SLAVE_ID_1_6[0],4,13))     
        # # # #밭
        sched.add_job(Service.Inv_Modbus_100kW, 'cron', second= Service_Cron,misfire_grace_time = 5,args=(FIELD_SERVER_IP,SERVER_PORT_4002,SETTING_100kW,SLAVE_ID_1_6[0],3,12))    #
        sched.add_job(DB.Inv_Modbus_100kW, 'cron', second= DB_Cron,misfire_grace_time = 5,args=(FIELD_SERVER_IP,SERVER_PORT_4002,SETTING_100kW,SLAVE_ID_1_6[0],3,12))    #
        try:
            while True:
                time.sleep(1)  # 메인 스레드가 종료되지 않도록 유지
        except (KeyboardInterrupt, SystemExit):
            # Ctrl+C 또는 시스템 종료 시 스케줄러 정지
            sched.shutdown()
#